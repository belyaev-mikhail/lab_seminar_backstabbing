---
lang: ru

theme: metropolis


title: 'Algebraic handling of loops: because why and how?'
author: Михаил Беляев
date: '\today'

csquotes: true
header-includes:
- |
  ```{=latex}
  \usepackage{csquotes}

  \newfontfamily\cyrillicfont{Fira Sans}
  \newfontfamily\cyrillicfonttt{Fira Mono}
  
  \setsansfont[BoldFont={Fira Sans Bold}, Scale=1.05]{Fira Sans}
  \setmonofont[Scale=0.95]{Fira Mono}

  \metroset{outer/numbering=fraction}
  \metroset{background=dark}
  \metroset{progressbar=frametitle}

  \definecolor{eigengrau}{rgb}{0.08627, 0.08627, 0.1137}
  \definecolor{gold}{rgb}{0.6509, 0.4863, 0.0001}
  
  \setbeamercolor{normal text}{bg=eigengrau,fg=white}
  \setbeamercolor{title separator}{fg=red}
  \setbeamercolor{frametitle}{bg=eigengrau,fg=gold}
  \setbeamercolor{progress bar}{bg=white,fg=red}
  ```

---

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
while(x < n) {
	x++ 
	y += x 
	assert(y < 1000 * n)
}
```

Чем нам этот цикл не нравится?

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
while(x < n) {
	x++    // 0, 1, 2, 3, 4 ...
	y += x // 2, 3, 5, 8, 12... 
	assert(y < 1000 * n)
}
```

Чем нам этот цикл не нравится?

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
for(i in 0 until n) {
	x = i
	y = 2 + (i * i + i) / 2
	assert(y < 1000 * n)
}
```

А если так?

# О чем вообще речь

Перейдём только к "внутренностям" цикла

```kotlin
assume(i >= 0)
assume(i < n)
x = i
y = 2 + (i * i + i) / 2
assert(y < 1000 * n)
```

# Чуть более формально

- Есть цикл: $\langle Init, ExitCond, Body \rangle$
- Всё это можно представить в виде логических формул
- Если мы можем:
	- Ввести свободную переменную i (число пройденных итераций)
	- Выразить $ExitCond$ и $Body$ через i и внешние переменные
- То весь цикл можно представить как $\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$
- Будем называть такое представление *идеальной аппроксимацией цикла*

# Идеальная аппроксимация цикла

- Весь цикл можно представить как $\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$
- Будем называть такое представление *идеальной аппроксимацией цикла*

- А зачем?

. . .

- На практике всё сложнее
	- Что делать с сайд-эффектами?
	- Что делать с ассертами?
	- И вообще, кванторы это фу

# Неидеальная аппроксимация цикла

Как нам (тезисно) предлагает поверить Кларк, придумавший всякий разный там model checking \
*Ошибки проявляются на конечных путях выполнения*

Как (тезисно) считаю я \
*Ошибки, связанные с циклами, проявляются на конечном числе итераций*

# Неидеальная аппроксимация цикла

Вместо идеальной аппроксимации

$\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$

Возьмём её подмножество

$\exists i,j,k . \ldots : Body(i) \land Body(j) \land Body(k)$

или даже

$\exists i . i > 0 \land \lnot ExitCond(i) : Body(i)$

Вопрос: чем один квантор лучше, чем другой?

# Чем один квантор лучше, чем другой?

- **Сколемизация** \
  В рамках решения задачи SMT кванторы существования на верхнем уровне можно просто *выкинуть*
- **Ассерты** \
  Как обобщать проверки, не всегда понятно, а на считанном числе итераций этого делать не нужно
- **Сайд-эффекты** \
  Не всегда, но аналогично

# Неидеальная аппроксимация цикла

А ещё мы можем выделить *последнюю* итерацию цикла (или $N$ последних):

$\exists i . i > 0 \land \lnot ExitCond(i) \land \underline{ExitCond(i + 1)} : Body(i)$

Если классическая раскрутка --- это раскрутка с начала, то тут мы это делаем *с конца*

Отсюда взялся термин loop backstabbing =)

# Ну очешуеть теперь

Идея-то огонь, а как это сделать-то?

- Выразить все индексные переменные через число итераций
- "Развязать" все зависимости между итерациями
- Желательно, оставаясь в рамках доступных теорий

Всегда ли это возможно?

# Всегда ли это возможно?

Рассмотрим почти такой же пример

```kotlin
val x = 1
val y = 1
while(x < n) {
	x += y // ?
	y += x // ?
}
```

# Всегда ли это возможно?

Рассмотрим почти такой же пример

```kotlin
for(i in 0 until n) {
	x = fib(i)
	y = fib(i + 1)
}
```

Где `fib` это функция подсчёта чисел Фибоначчи

Очевидно, в теории это не укладывается и задетектить такое тоже не выйдет

# А как это сделать-то?

- Выразить все индексные переменные через число итераций
- "Развязать" все зависимости между итерациями
- Желательно, оставаясь в рамках доступных теорий
- Понять, для каких значений это возможно, а для каких нет
