---
lang: ru

theme: metropolis


title: 'Algebraic handling of loops: because why and how?'
author: Михаил Беляев
date: '\today'

csquotes: true
header-includes:
- |
  ```{=latex}
  \usepackage{csquotes}

  \newfontfamily\cyrillicfont{Fira Sans}
  \newfontfamily\cyrillicfonttt{Fira Mono}
  
  \setsansfont[BoldFont={Fira Sans Bold}, Scale=1.05]{Fira Sans}
  \setmonofont[Scale=0.95]{Fira Mono}

  \metroset{outer/numbering=fraction}
  \metroset{background=dark}
  \metroset{progressbar=frametitle}

  \definecolor{eigengrau}{rgb}{0.08627, 0.08627, 0.1137}
  \definecolor{gold}{rgb}{0.6509, 0.4863, 0.0001}
  
  \setbeamercolor{normal text}{bg=eigengrau,fg=white}
  \setbeamercolor{title separator}{fg=red}
  \setbeamercolor{frametitle}{bg=eigengrau,fg=gold}
  \setbeamercolor{progress bar}{bg=white,fg=red}
  ```

---

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
while(x < n) {
	x++ 
	y += x 
	assert(y < 1000 * n)
}
```

Чем нам (анализатору) этот цикл не нравится?

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
while(x < n) {
	x++    // 0, 1, 2, 3, 4 ...
	y += x // 2, 3, 5, 8, 12... 
	assert(y < 1000 * n)
}
```

Чем нам этот цикл не нравится?

# О чём вообще речь

Рассмотрим цикл:

```kotlin
var x = 0
var y = 2
for(i in 0 until n) {
	x = i
	y = 2 + (i * i + i) / 2
	assert(y < 1000 * n)
}
```

А если так?

# О чем вообще речь

Перейдём только к "внутренностям" цикла

```kotlin
assume(i >= 0)
assume(i < n)
x = i
y = 2 + (i * i + i) / 2
assert(y < 1000 * n)
```

# Чуть более формально

- Есть цикл: $\langle Init, ExitCond, Body \rangle$
- Всё это можно представить в виде логических формул
- Если мы можем:
	- Ввести свободную переменную i (число пройденных итераций)
	- Выразить $ExitCond$ и $Body$ через i и внешние переменные
- То весь цикл можно представить как $\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$
- Будем называть такое представление *идеальной аппроксимацией цикла*

# Идеальная аппроксимация цикла

- Весь цикл можно представить как $\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$
- Будем называть такое представление *идеальной аппроксимацией цикла*

- А зачем?

. . .

- На практике всё сложнее
	- Что делать с сайд-эффектами?
	- Что делать с ассертами?
	- И вообще, кванторы это фу

# Неидеальная аппроксимация цикла

Как нам (тезисно) предлагает поверить Кларк, придумавший всякий разный там model checking \
*Ошибки проявляются на конечных путях выполнения*

Как (тезисно) считаю я \
*Ошибки, связанные с циклами, проявляются на конечном числе итераций*

# Неидеальная аппроксимация цикла

Вместо идеальной аппроксимации

$\forall i . i > 0 \land \lnot ExitCond(i) : Body(i)$

Возьмём её подмножество

$\exists i,j,k . \ldots : Body(i) \land Body(j) \land Body(k)$

или даже

$\exists i . i > 0 \land \lnot ExitCond(i) : Body(i)$

Вопрос: чем один квантор лучше, чем другой?

# Чем один квантор лучше, чем другой?

- **Сколемизация** \
  В рамках решения задачи SMT кванторы существования на верхнем уровне можно просто *выкинуть*
- **Ассерты** \
  Как обобщать проверки, не всегда понятно, а на считанном числе итераций этого делать не нужно
- **Сайд-эффекты** \
  Не всегда, но аналогично

# Неидеальная аппроксимация цикла

А ещё мы можем выделить *последнюю* итерацию цикла (или $N$ последних):

$\exists i . i > 0 \land \lnot ExitCond(i) \land \underline{ExitCond(i + 1)} : Body(i)$

Если классическая раскрутка --- это раскрутка с начала, то тут мы это делаем *с конца*

Отсюда взялся термин loop backstabbing =)

# Ну очешуеть теперь

Идея-то огонь, а как это сделать-то?

- Выразить все индексные переменные через число итераций
- "Развязать" все зависимости между итерациями
- Желательно, оставаясь в рамках доступных теорий

Всегда ли это возможно?

# Всегда ли это возможно?

Рассмотрим почти такой же пример

```kotlin
val x = 1
val y = 1
while(x < n) {
	x += y // ?
	y += x // ?
}
```

# Всегда ли это возможно?

Рассмотрим почти такой же пример

```kotlin
for(i in 0 until n) {
	x = fib(i)
	y = fib(i + 1)
}
```

Где `fib` это функция подсчёта чисел Фибоначчи

Очевидно, в теории это не укладывается и задетектить такое тоже не выйдет

# А как это сделать-то?

- Выразить все индексные переменные через число итераций
- "Развязать" все зависимости между итерациями
- Желательно, оставаясь в рамках доступных теорий
- Понять, для каких значений это возможно, а для каких нет

# Всё уже придумано до нас

*Практически* такую же задачу пытаются решать уже давно в рамках компиляторов

- Выделение основной индексной переменной
- Каноникализация циклов
- "Скалярные эволюции"

Зачем?

- Оптимизации циклов
- Раскрутка
- Векторизация
- Вычисление trip count
- etc.

# Chains of recurrencies/trees of recurrencies

Van Engelen, R. *Symbolic evaluation of chains of recurrences for loop optimization.* Technical Report TR-000102, Computer Science Department, Florida State University, 2000.

Pop, Sebastian, et al. *Fast recognition of scalar evolutions on three-address ssa code.* Technical Report A/354/CRI, Centre de Recherche en Informatique (CRI), École des mines de Paris, 2004. 

# Chains of recurrencies/trees of recurrencies

Описание эволюции одного значения в виде ChRec/TREC:

$$
\Theta_a = \{\Theta_b, \odot, \Theta_c\}_{l_N}
$$

- $\Theta_b$ --- начальное значение
- $\Theta_c$ --- дифф
- $\odot \in \{\times,+\}$
- $l_N$ --- цикл, в котором всё происходит

# Chains of recurrencies/trees of recurrencies

Пример:

- $x_{i + 1} = x_i + 2$ в цикле 1
- $\Theta_x = \{x_0, +, 2\}_{l_1}$

# Chains of recurrencies/trees of recurrencies

$$
\{\Theta_a, \odot_m, \{\Theta_b, \odot_n, \Theta_c\}_{l_N}\}_{l_N}
$$

записывается как

$$
\{\Theta_a, \odot_m, \Theta_b, \odot_n, \Theta_c\}_{l_N}
$$

# Итого: задачи

- Найти переменные, которые меняются
- Построить для каждой переменной цепочку
  - Найти начальное значение
  - Найти дифф
  - Найти операцию
- *Посчитать* по цепочке её значение

# Disclaimers

Мы будем говорить о модели "честного" SSA с $\varphi$-функциями

Например, LLVM IR или Abdullin KFG

# Вводные понятия (не очень формально)

*Индексная переменная* — цепочка значений, в которой значение на следующей итерации цикла зависит от значения с предыдущей итерации цикла

*Внутренняя переменная цикла* -- значение, которое меняется в цикле, но не индексная переменная

*Внешняя переменная цикла* -- значение, которое в цикле не меняется

# Вводные понятия (не очень формально)

*Заголовок цикла* -- входной базовый блок цикла

*Защёлка* -- базовый блок цикла, из которого есть переход в заголовок

Мы будем рассматривать циклы с одним заголовком и одной защёлкой

# Итого: задачи

- Найти переменные, которые меняются
- Построить для каждой переменной цепочку
  - Найти начальное значение
  - Найти дифф
  - Найти операцию
- *Посчитать* по цепочке её значение на определённой итерации

# Ищем переменные

- Внутренние переменные цикла искать не надо
  - Их всегда можно выразить через индексные и внешние
- Как найти индексные переменные?
  - Каждой соответствует loop-$\varphi$
  - $\varphi$-функция между защёлкой и заголовком
  - Значение из защёлки это предыдущая итерация
  - Значение не из защёлки это начальное значение

# Алгоритм (неформально)

- Берём произвольную loop-$\varphi$
- Раскрываем значение с предыдущей итерации, пока не:
  - Получилось выразить только через внешние переменные и саму $\varphi$
    - Закончили
  - Встретилась другая loop-$\varphi$
    - Сначала считаем её, возвращаемся
  - Встретилась не поддерживаемая инструкция
    - Не шмогла
- В процессе отслеживаем циклы между $\varphi$
  - Не шмогла

Делаем так для каждого цикла, начиная с наиболее вложенных

Но это ещё не конец!

# Алгоритм (неформально)

- Допустим, мы получили $f$ и $x_0$, такие, что $x_{i+1} = f(x_i, i)$
- Как отсюда перейти к $\Theta_x$?

Допустим, что $f(x, i) = \alpha(i) \times x + \beta(i)$


# Алгоритм (неформально)

$$f(x, i) = \alpha(i) \times x + \beta(i)$$

$$\Theta(x) = \{\{x_0, +, \beta, \times, \alpha^{-1}\}, \times, \alpha\}$$

Если $\alpha = 1$, получаем $\{x_0, +, \beta\}$

Если $\beta = 0$, получаем $\{x_0, \times, \alpha\}$

# Алгоритм (неформально)

Какие ещё случаи можно рассмотреть?

$$f(x, i) = x \texttt{<<} \alpha(i) \Rightarrow x_0 \texttt{<<} \{0, +, \alpha\} $$

$$f(x, i) = x \texttt{/} \alpha(i) \Rightarrow x_0 \texttt{/} \{1, \times, \alpha\} $$

. . .

В общем виде, если есть $f(x, i) = g(x, \alpha(i))$, где $\alpha$ не зависит от $x$, можно расширить формализм до $\{x_0, \underline{g}, \alpha\}$

# Начнём с конца!

Как посчитать по цепочке её значение?

$$
\Theta_x = \{\Theta_a, +, \Theta_b\}_{l_N}
$$

$$
x_i = \Theta_x(i) = \Theta_a(i) + \sum_{j = 1}^{i}{\Theta_b(j)}
$$

# Начнём с конца!

Как посчитать по цепочке её значение?

$$
\Theta_x = \{\Theta_a, \times, \Theta_b\}_{l_N}
$$

$$
x_i = \Theta_x(i) = \Theta_a(i) \times \prod_{j = 1}^{i}{\Theta_b(j)}
$$

# Начнём с конца!

Проблема нотации

$$
\Theta_x = \{\Theta_a, +, \Theta_b, +, \Theta_c, +, \Theta_d\}_{l_N}
$$

$$
x_i = \Theta_a(i) + \sum_{j = 1}^{i} \left(\Theta_b(j) + \sum_{k = 1}^{j} \left(\Theta_c(k) + \sum_{s = 1}^{k} \Theta_d(s)\right)\right)
$$

Не совсем корректно, но проще так:

$$
x_i = \Theta_a(i) + \sum_{i = 1}^{i} \left(\Theta_b(i) + \sum_{i = 1}^{i} \left(\Theta_c(i) + \sum_{i = 1}^{i} \Theta_d(i)\right)\right)
$$

# Суммы и произведения рядов

- Нужно уметь считать частичные суммы и произведения *в символьном виде*
- Желательно, ещё и быстро
- В статьях этого не умеют
- В общем случае невозможно

# Суммы и произведения рядов

- Нужен движок символьной арифметики
- На самом деле, он нам нужен ещё раньше, например, чтобы выделить $\alpha$ и $\beta$ в уравнениях для $x$
- Подходит что-то типа SymPy, но он на пайтоне и медленный

. . .

- Enter SymKt!

# SymKt

- https://github.com/vorpal-research/SymKt
- Умеет в "умную" нормализацию и в некоторое подмножество частичных сумм и произведений
- Алгоритмы украдены из SymPy, структуры данных из SymEngine

```kotlin
RowSum.of(Const.ONE, i) { i ->
  RowSum.of(Const.ONE, i) { i -> 
    RowSum.of(Const.ONE, i) { i -> Const(3) }
  }
}

> i + 3/2 * (i^2) + 1/2 * (i^3)
```

# Куда ещё можно (и хотелось бы) поехать

- Эволюции булей (никто не умеет afaik)

$$
\{true, \land, \alpha\} \Rightarrow \forall j. 1 \leq j \leq i : \alpha(j) 
$$

$$
\{false, \lor, \alpha\} \Rightarrow \exists j. 1 \leq j \leq i : \alpha(j) 
$$

# Куда ещё можно (и хотелось бы) поехать

Эволюции булей (никто не умеет afaik)

$$
\{true, \land, \alpha\} \Rightarrow \forall j. 1 \leq j \leq i : \alpha(j) 
$$

$$
\{false, \lor, \alpha\} \Rightarrow \exists j. 1 \leq j \leq i : \alpha(j) 
$$


# Куда ещё можно (и хотелось бы) поехать

Эволюции булей (никто не умеет afaik)

```kotlin
var isSorted = true
for(i in 0 until (e.size - 1)) {
  // isSorted = forall i.e[i] <= e[i+1]
  isSorted = isSorted && e[i] <= e[i + 1] 
  ...
}
```

# Куда ещё можно (и хотелось бы) поехать

Что с рекурсией?

- В принципе, подход строится поверх эволюций конкретных значений и это должно быть применимо к рекурсии
- Вместо номера итерации --- глубина рекурсии
- Но, кажется, это работает только в очень простых случаях (типа тех, что и так обрабатываются TCO)

# Куда ещё можно (и хотелось бы) поехать

Нужно искать синергию с другими подходами

# Ограничения

- На всех этапах может что-то не получиться
- Польза даже от произведений весьма сомнительна
    - Произведения можно посчитать, но там сплошные факториалы и степени, как их в солвер засовывать?
- Работа с памятью (нужно ещё копать)

# Что дальше можно делать с эволюциями?

- Сгенерировать из них обратно код
  - Так работал backstabbing в бореалисе
- Внести напрямую в предикатное представление
- Попытаться из них достать ещё какую-то информацию
  - Некоторые функции нельзя выразить в SMT, но можно использовать их свойства

# 

<https://github.com/belyaev-mikhail/lab_seminar_backstabbing>

<https://github.com/vorpal-research/symkt>

<https://github.com/belyaev-mikhail/kfg-evolutions>
